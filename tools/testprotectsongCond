#!/usr/bin/env python3

# Based on the previous protect song the recorded user password hashes are pulled into the python environment and user ecdh public keys are generated. These public keys are not stored but should be used in this environment for creating shared secrets. If the public keys are stored, then the shared secrets can be easily calculated since the shared secret function uses both the user generated secret (should be the public key) and the open song master key secret (song public key generated from random private key). So, overall, the input user private key is hashed and used to generate an ecdh public key. The public key is input to the ecdh shared key function along with the public key of the song (generated from ecdh keygen function using something random as the private key). A shared secret for the user is output. The generated shared secret is then used as an AES key to symmetrically encrypt the song private key (random key). In parallel to all this, the song is encrypted with the random key. Outside of this protectsong python script the random song key is unknown until it is decrypted with the individual user shared secrets.

import random
import string
import json
from ctypes import *
from argparse import ArgumentParser
from pydub import AudioSegment
#import numpy as np
import struct
import os
import wave
import numpy as np
import math
import sys


class ProtectedSong(object):
    """Example song object for protected song"""

    def __init__(self, path_to_song, metadata):
        """initialize values
        Args:
            path_to_song (string): file name where the song to be provisioned is stored
            metadata (bytearray): bytes containing metadata information
        """
        self.song = path_to_song
        self.full_song, self.original_song = self.read_song(path_to_song)
        #print("Full song")
        #print(self.original_song)
        self.songlen = len(self.full_song)
        self.padlen = math.ceil(self.songlen/16)*16
        self.metadata = metadata

    def save_secured_song_to_wave(self, file_location):
        """Saves secured song to wave file assuming all the same characteristics as original song
        Args:
            file_location (string): location to store the file including name"""
        protected_wav = wave.open(os.path.abspath(file_location), 'wb')
        protected_wav.setnchannels(self.original_song.getnchannels())
        protected_wav.setsampwidth(self.original_song.getsampwidth())
        protected_wav.setframerate(self.original_song.getframerate())
        protected_wav.writeframes(self.metadata)

        #Call enc_song function
        #Pass self.full_song into enc_song function and ouptut int array 	
        

        for val in self.full_song:
            protected_wav_val = struct.pack('<h', val)  

            protected_wav.writeframesraw(protected_wav_val)

        protected_wav.close()

    def read_song(self, path, metadata_frames=0):
        """Reads a wave file
        Args:
            path (string): path to song
            metadata_frames (int): if not 0 disregard this number of frames as metadata
        Returns:
            vals (array): integer array of decoded values
            song (Wave Object): wave object associated with entered song
        """
        song = wave.open(os.path.abspath(path), 'r')
        if metadata_frames:
            song.readframes(metadata_frames)  # skip the metadata frames when assigning vals
        vals = np.frombuffer(song.readframes(song.getnframes()), dtype=np.int16)
        song.close()
        return vals, song


def create_metadata(regions, user, user_secret_location, region_info):
    """Returns a byte string formatted as follows:
    METADATA_LENGTH(1B)/ownerID(1B)/REGION_LEN(1B)/USER_LEN(1B)/REGIONID1(1B)/REGIONID2 (1B)/.../opt. parity
    Args:
        regions (list): list of regions to provision song for
        user (string): user name for owner of the song
        user_secret_location (string): path to user secrets file
        region_info (dict): mapping of regions provided by region_information.json
    Returns:
        metadata (bytes): bytes of encoded metadata
    Example:
        >>create_metadata(['USA', 'Canada'], 'user1', 'user_secrets.json', {'USA': 1, 'Canada':2})
        'x06/x00/x01/x00/x01/x02'
    """
    user_secrets = json.load(open(os.path.abspath(user_secret_location)))

    # note: metadata must be an even length since each sample is 2B long
    # and ARM processors require memory accesses to be aligned to the type size
    metadata = struct.pack(
        '=3B{regions_length}s{regions_len_2}s'.format(regions_length=len(regions), regions_len_2=len(regions) % 2),
        int(user_secrets[user]['id']), len(regions), 0,
        bytes([region_info[str(r)] for r in regions]),
        b'\x00' if len(regions) % 2 else b'')

    return bytes([len(metadata) + 1]) + metadata


#Creates random password
def randomStringDigits(stringLength=10):
    """Generate a random string of letters and digits """
    lettersAndDigits = string.ascii_letters + string.digits
    return ''.join(random.choice(lettersAndDigits) for i in range(stringLength))


def main():
    parser = ArgumentParser(description='main interface to protect songs')
    parser.add_argument('--region-list', nargs='+', help='List of regions song can be played in', required=True)
    parser.add_argument('--region-secrets-path', help='File location for the region secrets file',
                        required=True)
    parser.add_argument('--outfile', help='path to save the protected song', required=True)
    parser.add_argument('--infile', help='path to unprotected song', required=True)
    parser.add_argument('--owner', help='owner of song', required=True)
    parser.add_argument('--user-secrets-path', help='File location for the user secrets file', required=True)
    args = parser.parse_args()

    regions = json.load(open(os.path.abspath(args.region_secrets_path)))
    try:
        metadata = create_metadata(args.region_list, args.owner, args.user_secrets_path, regions)
    except ValueError:
        raise ValueError('Ensure all user IDs are integers and all regions are in the provided region_information.json')
    protected_song = ProtectedSong(args.infile, metadata)


    #RETRIEVE THE RECORDED PINS AND USERS----------------------------
    try:
        lib = './setsecs2.so'
        dll = CDLL(lib)
        dll.sha256hash.restype = c_char_p #Override default return type
        dll.encsongkey.restype = c_char_p
        dll.retrievePub.restype = c_char_p 
        #dll.enc_song.restype = c_int * protected_song.padlen

        f = open('record', 'r')
        ps = f.readlines()
    #Pins need parsing
        ps[0] = ps[0].replace('[', '')
        ps[0] = ps[0].replace(']', '')
        ps[0] = ps[0].replace('"', '')
        pins = ps[0].split(', ')

        g = open('usernames', 'r')
        ps = g.readlines()
    #Users need parsing
        ps[0] = ps[0].replace('[', '')
        ps[0] = ps[0].replace(']', '')
        ps[0] = ps[0].replace('"', '')
        users = ps[0].split(', ')
    except:
        raise Exception(
            "An issue is present with reading record!")
    f.close()
    g.close()

    #SONG MAP------------------------------------------------- (Initial setup)
    #Create map file name
    songmapfile = args.outfile
    songmapfile = songmapfile.replace("global_provisioning/audio/","")
    songname = songmapfile.replace(".drm","")
    songmapfile = songmapfile + "_map"
    songmap = open(songmapfile, "w")

    #Create song key
    song_key = randomStringDigits(16)
    songK = song_key.encode('utf-8')

    #Create song map
    name = "master"
    mpb = dll.retrievePub(create_string_buffer(name.encode('utf-8'))).decode('utf-8')
    userpin = create_string_buffer(pins[users.index(args.owner)].encode('utf-8'))
    masterpub = create_string_buffer(mpb.encode('utf-8'))
    encsongKstring = dll.encsongkey(userpin, masterpub, songK).decode('utf-8')
    print("Encrypted song key: ")
    print(encsongKstring)

    #Write to song map
    dict_line = args.owner + " " + encsongKstring + "\n"
    songmap.write(dict_line)
    
    songmap.close()
    #------------------------------------------------------------

    #print("Song Before:")
    #print(protected_song.full_song[-1-200:-1])
    #print("Song Length:")
    
    #print(protected_song.songlen)
    #print(protected_song.full_song.dtype)
    
    songarr = (c_uint8 * protected_song.songlen)(*protected_song.full_song)
    encoded = (c_uint8 * protected_song.songlen)(*protected_song.full_song)

    #print(encoded[0])
    #print(encoded[16])
    print("Encrypting song...")
    dll.enc_song(songarr, songK, c_int(protected_song.padlen),encoded)
    #print("Song After:")

     

    protected_song.full_song = np.array(encoded, dtype=np.int16)
    #print(protected_song.full_song[0:15])
    #print(protected_song.full_song[-1-200:-1])
    #test.astype(int8)
    #print(protected_song.full_song.dtype)

    #for i in range(15):
        #print(i)
     #   print(test[i])
    #print(np.int16(encoded[1]))

    protected_song.save_secured_song_to_wave(args.outfile)


    #Drop demo
	
    #30 seconds demo
    input_audio = args.infile
    myaudio = AudioSegment.from_file(input_audio, format="wav")

    demo_ms = 30000 # pydub calculates in millisec
    demo_song = myaudio[:demo_ms] # splice from start to specified time
    
    chunk_name = "global_provisioning/audio/" + songname + "_demo.drm"
    #print ("exporting", chunk_name)
    demo_song.export(chunk_name, format="wav") # Export as wav file


if __name__ == '__main__':
    main()


